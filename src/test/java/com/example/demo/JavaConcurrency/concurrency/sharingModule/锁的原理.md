# Java对象头
synchronized用的锁是存在Java对象头里的

数组类型的对象的对象头为3字宽，其他为2字宽

这里以32位虚拟机举例，1字宽为4字节(32bit)

普通对象的对象头
![img.png](otherFile/img.png)
数组对象的对象头
![img_1.png](otherFile/img_1.png)

其中markword的结构：
![img_2.png](otherFile/img_2.png)

锁标志位的不同，markword会变化为存储以下四种数据
![img_3.png](otherFile/img_3.png)
其中指向互斥量的指针就是指向monitor的指针

对于64位的虚拟机，markword的结构如下
![img_4.png](otherFile/img_4.png)

# monitor原理
不加 synchronized 的对象不会关联监视器
monitor结构如下：
![img_5.png](otherFile/img_5.png)

线程Thread2要对对象obj加锁的时候，obj的markword会指向monitor对象，thread2指向monitor的owner字段，从而实现对这个锁的占用
![img_6.png](otherFile/img_6.png)
当另一个线程thread1想要获取obj的锁时候，会先检查对象的monitor的owener是否与其他线程关联

这里发现已经被线程thread2占用，会关联monitor的entryList，从而进入等待队列，将自己阻塞
![img_7.png](otherFile/img_7.png)
再来的线程也会进入entryList
![img_8.png](otherFile/img_8.png)

## 源码分析
Java代码
```java
static final Object lock = new Object();
static int counter = 0;
public static void main(String[] args) {
 synchronized (lock) {
 counter++;
 }
}
```
对应的字节码
```text
 Code:
 stack=2, locals=3, args_size=1
 0: getstatic #2 // <- lock引用 （synchronized开始）
 3: dup
 4: astore_1 // lock引用 -> slot 1
 5: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针
 6: getstatic #3 // <- i
 9: iconst_1 // 准备常数 1
 10: iadd // +1
 11: putstatic #3 // -> i
 14: aload_1 // <- lock引用
 15: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList
 16: goto 24
 19: astore_2 // e -> slot 2 
 20: aload_1 // <- lock引用
 21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList
 22: aload_2 // <- slot 2 (e)
 23: athrow // throw e
 24: return
 Exception table:
 from to target type
 6 16 19 any
 19 22 19 any
```